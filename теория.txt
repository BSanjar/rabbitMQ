RabbitMQ часто сравнивают с другим популярным брокером сообщений — Apache Kafka. Оба инструмента используются для обмена данными между приложениями, но реализуют принципиально разные модели доставки. RabbitMQ — push, когда сообщения отправляются получателям, а Kafka — pull, получатели сами достают сообщения из топика. 

Принцип работы выглядит так:
RabbitMQ принимает сообщения от поставщиков, отправляет подтверждение о приёме и перенаправляет сообщение получателям.
Получатели подтверждают, что сообщение доставлено, или сигнализируют о неудачной доставке. Во втором случае сообщение остаётся в очереди до тех пор, пока не будет доставлено.
После доставки сообщение удаляется из системы. 

В очереди может храниться любой объём сообщений от неограниченного количества поставщиков, а получать их может неограниченное количество подписчиков. Фишка RabbitMQ как раз в гибкой маршрутизации — одно и то же сообщение могут получить сразу несколько подписчиков. Сначала оно попадёт на узел, а оттуда в очереди для всех подписчиков, которым должно быть доставлено. Благодаря такой особенности RabbitMQ подходит для нетривиальных бизнес-процессов и позволяет настраивать сложные системы с тысячами источников и приемников сообщений. 

Где может применяться: системы бронирования билетов, логистические программы.

В отличие от большинства систем, очередь сообщений в Kafka является постоянной. Отправленные данные хранятся до тех пор, пока не истечет указанные период. Сообщения не удаляются после получения, их можно перечитывать. 

В RabbitMQ сообщение хранится до тех пор, пока принимающее приложение не получит его из очереди. Как только подписчик отмечает, что сообщение получено, оно удаляется. 

Главное преимущество RabbitMQ — гибкая маршрутизация. Сообщения маршрутизируются через обменник (exchange) перед попаданием в очереди. RabbitMQ предлагает несколько видов маршрутизации сообщений на стороне сервера (т.е. на стороне брокера) с помощью ключей, описанных в протоколе AMQP. 

У Kafka упрощённый подход к маршрутизации. Возможности, аналогичные RabbitMQ, она предоставляет через Kafka Connect и Kafka Streams. Эти компоненты выполняются на отдельном уровне и не являются функциями по умолчанию. 

Что есть у RabbitMQ и чего нет у Kafka
Масштабирование и поддержание порядка сообщений возможно с помощью каждого из брокеров сообщений. При этом у RabbitMQ есть одна интересная особенность, которой нет у Kafka: он позволяет подписчикам создавать произвольные группы событий.

Разберём на примере: разные приложения не могут совместно использовать очередь, потому что тогда они будут конкурировать за получение сообщений. Каждому из них нужна собственная очередь, которую они смогут настраивать так, как считают нужным. Это позволяет приложениям поддерживать порядок связанных событий. 